üóì 2025-12-11 ‚Äì Journal de dev Longoka Games / Scrabble Kikongo

Contexte g√©n√©ral

Objectif : construire un backend Java pour des jeux de lettres (mots m√™l√©s, crois√©s, etc.) en Kikongo (puis Lingala), en s‚Äôappuyant directement sur la base Lexikongo (6i695q_lexikongo) et une base d√©di√©e aux jeux (6i695q_games_stock).

Stack backend :

Java 17

Maven (projet longoka-games-backend)

MySQL (Infomaniak)

JDBC + mysql-connector-j

‚úÖ Avanc√©es du jour
1. Projet Java / Maven fonctionnel

Projet Maven longoka-games-backend compil√© avec succ√®s (mvn compile OK).

D√©pendances ajout√©es et t√©l√©charg√©es correctement :

mysql-connector-j (driver MySQL)

protobuf-java (pr√©vu pour √©changes / formats plus tard)

plugins Maven (compiler, exec, etc.)

2. Configuration DB centralis√©e (DbConfig)

Fichier : src/main/java/com/longoka/games/app/DbConfig.java

Gestion d‚Äôun profil d‚Äôenvironnement :

variable d‚Äôenvironnement GAMES_ENV

local (par d√©faut) ‚Üí lit config/db-local.properties

plus tard : prod ‚Üí config/db-prod.properties

Chargement du fichier config/db-local.properties avec log :

exemple : Config DB (local) charg√©e depuis D:\works\lectures\longoka-games\backend-java\config\db-local.properties

M√©thodes utilitaires mises en place :

openKikongoLexConnection() ‚Üí connexion √† 6i695q_lexikongo

openGamesStockConnection() ‚Üí connexion √† 6i695q_games_stock

(Hooks pr√™ts pour Lingala : openLingalaLexConnection())

Important :
Les URLs JDBC utilisent d√©sormais useUnicode=true&useSSL=false sans characterEncoding=utf8mb4 pour √©viter l‚Äôexception Unsupported character encoding 'utf8mb4' avec le JDK Windows.

3. Fichier db-local.properties (local ‚Üí Infomaniak)

Dans config/db-local.properties :

Partie Kikongo (Lexikongo) :

lex.kg.host=6i695q.myd.infomaniak.com
lex.kg.port=3306
lex.kg.name=6i695q_lexikongo
lex.kg.user=6i695q_cedric
lex.kg.pass=***masqu√©***


Partie Games stock (d√©j√† pr√™te m√™me si pas encore utilis√©e par Java) :

games.db.host=6i695q.myd.infomaniak.com
games.db.port=3306
games.db.name=6i695q_games_stock
games.db.user=6i695q_cedric
games.db.pass=***masqu√©***


Le chargement de ce fichier est confirm√© dans la console.

4. Connexion r√©elle √† Lexikongo (Infomaniak)

Classe de test :
src/main/java/com/longoka/games/app/TestLexikongoVerbs.java

Utilise maintenant :

try (Connection conn = DbConfig.openKikongoLexConnection()) {
    // ...
}


Repository : LexikongoVerbRepository branch√© sur cette connexion.

M√©thode utilis√©e : findRandomVerbsByLength(4, 8, 10).

R√©sultat : Build + ex√©cution OK

== Test connexion Lexikongo (Kikongo) ==
Config DB (local) charg√©e depuis ... db-local.properties
‚úÖ Connexion √† la base Kikongo OK
Verbes tir√©s al√©atoirement :
 - LexVerb{verbId=329, slug='sikula', name='Sikula', gridForm='SIKULA', gridLength=6, derivedVerb=false}
 - LexVerb{verbId=259, slug='vanga', name='Vanga', gridForm='VANGA', gridLength=5, derivedVerb=false}
 - LexVerb{verbId=317, slug='yela', name='Yela', gridForm='YELA', gridLength=4, derivedVerb=false}
 - LexVerb{verbId=7, slug='tunga', name='Tunga', gridForm='TUNGA', gridLength=5, derivedVerb=false}
 - LexVerb{verbId=321, slug='vinga', name='Vinga', gridForm='VINGA', gridLength=5, derivedVerb=true}
 - LexVerb{verbId=14, slug='seasa', name='Seasa', gridForm='SEASA', gridLength=5, derivedVerb=false}
 - LexVerb{verbId=233, slug='tekela', name='Tekela', gridForm='TEKELA', gridLength=6, derivedVerb=false}
 - LexVerb{verbId=322, slug='vinduna', name='Vinduna', gridForm='VINDUNA', gridLength=7, derivedVerb=false}
 - LexVerb{verbId=4, slug='moka', name='Moka', gridForm='MOKA', gridLength=4, derivedVerb=false}
 - LexVerb{verbId=2, slug='finga', name='Finga', gridForm='FINGA', gridLength=5, derivedVerb=false}


‚úÖ √áa prouve que :

La connexion r√©seau vers Infomaniak fonctionne en Java.

On sait interroger les verbes Kikongo avec filtre de longueur.

On a d√©j√† un mini ‚ÄúAPI interne‚Äù pour piocher des verbes adapt√©s aux grilles de jeu.

üß† D√©cision importante du jour

Abandon de la table tampon lex_items dans 6i695q_games_stock.

Strat√©gie retenue : lire directement dans la DB Lexikongo au moment de la g√©n√©ration de jeux.

Avantages :

Pas besoin de synchroniser r√©guli√®rement une table miroir.

Les nouveaux mots ajout√©s dans Lexikongo sont automatiquement disponibles pour les jeux.

Moins de maintenance √† long terme.

üîú Prochaines √©tapes (pour demain)

Mod√®le de puzzle c√¥t√© Java

Cr√©er une classe WordSearchPuzzle pour repr√©senter un jeu de mots m√™l√©s :

grille (char[][] ou List<String>)

liste de mots + positions

√©ventuellement niveau / id / m√©tadonn√©es

G√©n√©rateur de mots m√™l√©s

Classe WordSearchGenerator :

prend une liste de LexVerb (ou lex√®mes plus tard : noms + verbes),

choisit quelques mots,

tente de les placer dans la grille:

d‚Äôabord horizontal (gauche‚Üídroite),

puis vertical (haut‚Üíbas),

collisions support√©es,

compl√©tion par lettres al√©atoires.

Test end-to-end

Nouvelle classe TestWordSearchFromVerbs :

ouvre connexion Kikongo,

r√©cup√®re des verbes (LexikongoVerbRepository),

g√©n√®re un WordSearchPuzzle,

affiche la grille dans la console (mode ‚Äúdebug‚Äù).

Plus tard :

Brancher cette logique sur la base 6i695q_games_stock :

enregistrer un puzzle g√©n√©r√© dans la table puzzles (type word_search),

relier √† packs, languages, etc.

Si tu veux demain, on repart directement de cette section ‚ÄúProchaines √©tapes‚Äù et on √©crit le code des classes WordSearchPuzzle, WordSearchGenerator et TestWordSearchFromVerbs brique par brique.

Pour l‚Äôinstant : mission du soir accomplie ‚úÖ
Tala mbote, on garde la machine bien chauff√©e pour demain üòÑ

//// le 11/12/2025
3Ô∏è‚É£ Ce qu‚Äôon a VRAIMENT maintenant (bilan rapide)

Avec :

les tables bien d√©crites (verbs, words, slugs, verb_meanings, word_meanings, nominal_classes)

les bases Kikongo (6i695q_lexikongo) et Lingala (6i695q_lexilingala)

DbConfig avec openKikongoLexConnection() et openLingalaLexConnection()

les POJO + repositories dans com.longoka.games.lexikongo

üëâ On a d√©j√† un noyau solide qui permet :

De r√©cup√©rer des verbes (Kikongo/Lingala) avec tous leurs champs + slug + traductions FR/EN/‚Ä¶

De r√©cup√©rer des noms (Kikongo/Lingala) avec :

singulier / pluriel

classe nominale (via nominal_classes)

slug

significations FR/EN

info d√©riv√© / non d√©riv√©

C‚Äôest exactement la base pour :

moteurs de jeux (mots m√™l√©s, pendu, grilles, conjugaison, d√©riv√©s, etc.),

g√©n√©rateurs de livres (via scripts InDesign),

quiz de grammaire (classes nominales, d√©riv√©s, nombres‚Ä¶),

et plus tard, API REST.
///
üî• Build SUCCESS = nos mod√®les & repos sont propres et compilent.
√áa veut dire : on a maintenant une API Java s√©rieuse pour piocher les verbes / mots Kikongo et Lingala depuis les deux bases.

Je r√©cap tout ce qu‚Äôon a pos√© et ce que tu peux faire maintenant, tr√®s concr√®tement.

1Ô∏è‚É£ O√π on en est exactement

Dans com.longoka.games.lexikongo tu as maintenant :

LexVerb ‚Üê wrapper riche autour de verbs + slugs + verb_meanings

LexWord ‚Üê wrapper riche autour de words + slugs + nominal_classes + word_meanings

LexMeaning

NumberVariability

NominalClass

LexikongoVerbRepository

LexikongoWordRepository

Et c√¥t√© connexion DB (Kikongo / Lingala / stock jeux) :

com.longoka.games.app.DbConfig avec :

openKikongoLexConnection() ‚Üí 6i695q_lexikongo (Kikongo)

openLingalaLexConnection() ‚Üí 6i695q_lexilingala (Lingala)

etc.

Tout √ßa compile ‚úÖ ‚Üí on peut maintenant consommer les vraies donn√©es de prod.

2Ô∏è‚É£ Exemple concret : r√©cup√©rer des verbes Kikongo utilisables en jeu

Tu peux coller ce genre de code dans n‚Äôimporte quelle classe avec un main, par exemple KikongoWordsTool ou un futur GameSandboxMain :

package com.longoka.games.app;

import com.longoka.games.lexikongo.LexVerb;
import com.longoka.games.lexikongo.LexikongoVerbRepository;

import java.sql.Connection;
import java.util.List;

public class KikongoVerbsDemo {

    public static void main(String[] args) throws Exception {
        try (Connection conn = DbConfig.openKikongoLexConnection()) {

            LexikongoVerbRepository repo = new LexikongoVerbRepository(conn);

            // Exemple : 12 verbes de longueur 4 √† 8, avec sens FR
            List<LexVerb> verbs = repo.findRandomVerbsByLength(4, 8, 12, "fr");

            System.out.println("=== Verbes Kikongo (pour un jeu) ===");
            for (LexVerb v : verbs) {
                System.out.println("- " + v.getName() + " [" + v.getSlug() + "]");
                v.getMeanings().forEach(m ->
                    System.out.println("    (" + m.getLanguageCode() + ") " + m.getText())
                );
            }
        }
    }
}


Ensuite tu l‚Äôex√©cutes avec Maven :

mvn exec:java "-Dexec.mainClass=com.longoka.games.app.KikongoVerbsDemo"


üëâ √áa te donne directement un pool de verbes jouables : on a tout pour faire des QCM, m√©mory, jeu de grille, etc.

3Ô∏è‚É£ Exemple : mots + classes nominales (Kikongo)

Tu as d√©j√† KikongoWordsTool.java dans com.longoka.games.app.
On peut le transformer en outil utile (plus un test jetable) en le remplissant comme ceci :

package com.longoka.games.app;

import com.longoka.games.lexikongo.LexWord;
import com.longoka.games.lexikongo.LexikongoWordRepository;

import java.sql.Connection;
import java.util.Arrays;
import java.util.List;

public class KikongoWordsTool {

    public static void main(String[] args) throws Exception {
        try (Connection conn = DbConfig.openKikongoLexConnection()) {

            LexikongoWordRepository repo = new LexikongoWordRepository(conn);

            // Exemple 1 : 15 mots al√©atoires toutes classes confondues
            List<LexWord> allRandom = repo.findRandomWords(15, "fr");
            System.out.println("=== 15 mots Kikongo (toutes classes) ===");
            printWords(allRandom);

            // Exemple 2 : 10 mots uniquement des classes ki-bi (par ex. class_id = 4) + mu-ba (class_id = 1)
            List<LexWord> classFiltered = repo.findRandomWords(
                    Arrays.asList(4, 1), // √† adapter √† tes IDs r√©els de nominal_classes
                    10,
                    "fr"
            );
            System.out.println();
            System.out.println("=== 10 mots Kikongo (classes ki-bi & mu-ba) ===");
            printWords(classFiltered);
        }
    }

    private static void printWords(List<LexWord> words) {
        for (LexWord w : words) {
            String label = w.getSingular();
            if (w.getPlural() != null && !w.getPlural().isBlank()) {
                label += " / " + w.getPlural();
            }

            System.out.println("- " + label +
                    "  [" + w.getNominalClassName() + " ; " + w.getSlug() + "]");

            w.getMeanings().forEach(m ->
                    System.out.println("    (" + m.getLanguageCode() + ") " + m.getText())
            );
        }
    }
}


Ex√©cution :

mvn exec:java "-Dexec.mainClass=com.longoka.games.app.KikongoWordsTool"


üëâ L√† tu vois tr√®s vite :

les mots r√©els,

leur classe nominale (class_name),

les sens FR li√©s,

et tu peux d√©j√† imaginer :
¬´ Filtrer les mots de ki-bi et faire un jeu ‚Äúsingulier ‚Üî pluriel‚Äù ou ‚Äúclasse ‚Üî mot‚Äù ¬ª.

4Ô∏è‚É£ M√™me chose pour Lingala, sans rien r√©√©crire

Pour Lingala, c‚Äôest exactement la m√™me API Java,
tu changes juste la connexion :

package com.longoka.games.app;

import com.longoka.games.lexikongo.LexVerb;
import com.longoka.games.lexikongo.LexikongoVerbRepository;

import java.sql.Connection;
import java.util.List;

public class LingalaVerbsDemo {

    public static void main(String[] args) throws Exception {
        try (Connection conn = DbConfig.openLingalaLexConnection()) {

            LexikongoVerbRepository repo = new LexikongoVerbRepository(conn);

            // 10 verbes Lingala (longueur 4-8, avec sens FR si dispo)
            List<LexVerb> verbs = repo.findRandomVerbsByLength(4, 8, 10, "fr");

            System.out.println("=== Verbes Lingala ===");
            for (LexVerb v : verbs) {
                System.out.println("- " + v.getName() + " [" + v.getSlug() + "]");
                v.getMeanings().forEach(m ->
                        System.out.println("    (" + m.getLanguageCode() + ") " + m.getText())
                );
            }
        }
    }
}


Et pareil si tu veux les mots Lingala :
tu r√©utilises LexikongoWordRepository,
mais avec openLingalaLexConnection().

5Ô∏è‚É£ Pourquoi c‚Äôest ‚Äúcostaud‚Äù maintenant (et pas un simple test)

Ce qu‚Äôon vient de poser, ce n‚Äôest pas du code de d√©mo :

Les mod√®les couvrent tous les champs utiles des tables :

verbs, words, slugs, verb_meanings, word_meanings, nominal_classes.

Les repos sont :

typ√©s,

safe (Integer pour les FK nullables),

pr√™ts √† √™tre utilis√©s dans un backend HTTP ou une API de jeux.

La m√™me couche fonctionne pour :

lexikongo (Kikongo),

lexilingala (Lingala),
en changeant juste la connexion DB.
//
Je te fais un bilan clair de nos objectifs, de ce qu‚Äôon a d√©j√† et de ce qu‚Äôon attaque en premier (mots m√™l√©s, puis crois√©s).

1. La grande vision (ce qu‚Äôon construit √† long terme)

√Ä partir de ce que tu as d√©j√† :

Cours Longoka : Kikongo, Lingala facile, Mandombe, Natikongo

Lexikongo (Kikongo) + futur Lexilingala : dictionnaires complets, phon√©tique, traductions FR/EN, comptes, etc. 

brainstorming-longokaGames

Boutique Longoka /shop pour vendre livres de jeux, cahiers, PDF, etc. 

brainstorming-longokaGames

On veut construire un √©cosyst√®me :

Moteur de jeux de mots (Java/C++) connect√© directement aux bases Lexikongo / Lexilingala.

Apps de jeux (d‚Äôabord backend Java, plus tard app Android native) :

mots m√™l√©s,

mots crois√©s / fl√©ch√©s,

Scrabble-like, pendu, anagrammes, quiz, etc.

Livres de jeux (mots m√™l√©s, crois√©s‚Ä¶) g√©n√©r√©s via scripts InDesign √† partir du m√™me moteur.

Plus tard : plateforme enseignants / √©coles, packs par langue (Kikongo, Lingala, puis Yoruba, Swahili, etc.). 

brainstorming-longokaGames

2. Objectif pr√©cis du projet Java longoka-games-backend

Ce backend Java, c‚Äôest le c≈ìur logique c√¥t√© serveur / outils :

Se connecter aux DB existantes sur Infomaniak :

6i695q_lexikongo (Kikongo)

6i695q_lexilingala (Lingala, m√™me sch√©ma)

6i695q_games_stock (base jeux d√©di√©e) 

üóì 2025-12-11 ‚Äì Journal de dev ‚Ä¶

Mod√©liser proprement ton lexique c√¥t√© Java :

LexVerb ‚Üî table verbs (+ verb_meanings, slugs)

LexWord ‚Üî table words (+ word_meanings, slugs, nominal_classes) 

üóì 2025-12-11 ‚Äì Journal de dev ‚Ä¶

g√©rer : singulier, pluriel, classe nominale, d√©riv√©s, phon√©tique, etc. sans inventer de champs (on suit exactement les DESCRIBE que tu m‚Äôas donn√©s).

Repositories robustes :

LexikongoVerbRepository : verbes (avec meanings, slug‚Ä¶)

LexikongoWordRepository : noms (avec classe nominale, meanings, slug‚Ä¶)

utilisables pour Kikongo & Lingala (m√™me code, connexion diff√©rente). 

üóì 2025-12-11 ‚Äì Journal de dev ‚Ä¶

Moteur de jeux :

d‚Äôabord g√©n√©rer des mots m√™l√©s (word search),

ensuite des mots crois√©s,

puis, plus tard, Scrabble, etc.

Export propre (JSON) pour :

l‚Äôapp de jeux,

les scripts InDesign (livres de jeux).

3. O√π on en est techniquement maintenant

D‚Äôapr√®s le journal de dev + ce que tu viens de montrer : 

üóì 2025-12-11 ‚Äì Journal de dev ‚Ä¶

Projet Maven longoka-games-backend :

Java 17, build OK (mvn compile = ‚úÖ).

DbConfig centralis√© dans com.longoka.games.app.DbConfig :

charge config/db-local.properties (profil local via GAMES_ENV).

m√©thodes :

openKikongoLexConnection() ‚Üí 6i695q_lexikongo

openLingalaLexConnection() ‚Üí 6i695q_lexilingala

openGamesStockConnection() ‚Üí 6i695q_games_stock (pr√™t pour plus tard).

Connexion r√©elle √† la DB Kikongo test√©e et OK :

on a d√©j√† tir√© des verbes al√©atoires par longueur depuis LexikongoVerbRepository. 

üóì 2025-12-11 ‚Äì Journal de dev ‚Ä¶

Mod√®le Lexikongo :

LexVerb, LexWord, LexMeaning, NominalClass, NumberVariability, etc.

LexikongoVerbRepository et LexikongoWordRepository existent d√©j√† dans com.longoka.games.lexikongo.

On a aussi pris une d√©cision importante :
üëâ pas de table tampon lex_items : on lit directement dans Lexikongo / Lexilingala au moment de g√©n√©rer les jeux. 

üóì 2025-12-11 ‚Äì Journal de dev ‚Ä¶

4. Quels jeux, dans quel ordre ?

Tu as plusieurs jeux possibles (mots m√™l√©s, crois√©s, Scrabble, pendu, quiz, etc.), mais on a d√©j√† d√©cid√© d‚Äôun ordre de priorit√© : 

brainstorming-longokaGames

Jeux Mots m√™l√©s :

d‚Äôabord en Kikongo,

le m√™me en Lingala (m√™me moteur, autre DB).

Jeux Mots crois√©s / fl√©ch√©s :

avec d√©finitions (FR ‚Üî Kikongo/Lingala),

r√©utilisation de la structure lexicale + cours (lexique, affixes, classes, substantifs d√©riv√©s, etc.).

Ensuite (plus tard) :

Scrabble-like,

pendu,

anagrammes,

quiz (par le√ßons / cours Longoka),

etc.

Donc oui : on commence bien par un d√©but clair ‚Üí
üëâ Mots m√™l√©s Kikongo, puis Mots m√™l√©s Lingala, puis on enrichit.

5. Pourquoi il y avait encore des Test... & KikongoVerbsTool ?

Tu as parfaitement raison :
les classes TestLexikongoVerbs / KikongoVerbsTool √©taient juste des outils de test temporaire pour :

v√©rifier la connexion DB,

v√©rifier que le repository renvoyait bien des verbes.

Maintenant :

tu as supprim√© les doublons et les anciennes classes de test,

le projet compile proprement,

on peut repartir sans polluer avec des main() de test partout.

√Ä partir de maintenant, on reste sur du code ‚Äús√©rieux‚Äù / r√©utilisable :

POJO + repositories (d√©j√† faits),

plus des classes de service et de g√©n√©ration de puzzles.

Si on a besoin d‚Äôun mini main() de debug, on le fait proprement (ex: DemoWordSearchGenerator) et on assume que c‚Äôest un utilitaire, pas le c≈ìur du projet.

6. Plan concret imm√©diat (sans perdre le fil)

Maintenant que tout compile et que les tests jetables sont nettoy√©s, voil√† ce qu‚Äôon fait ensuite, clairement :

6.1. Solidifier Kikongo & Lingala c√¥t√© lexique

V√©rifier que LexVerb et LexWord mappent bien tous les champs importants des tables que tu m‚Äôas montr√©es :

verbs : verb_id, name, root, suffix, phonetic, active_verb, derived_verb, derived_from, is_approved, etc.

words : word_id, singular, plural, root, class_id, phonetic, derived_word, derived_from_word, derived_from_verb, is_approved, number_variability, etc.

plus : slug depuis slugs, significations depuis verb_meanings & word_meanings, classe depuis nominal_classes.

üëâ Aucune approximation : on suit exactement le DESCRIBE que tu as donn√©.

S‚Äôassurer que les repositories :

peuvent filtrer par langue (language_code dans meanings),

peuvent piocher dans Kikongo (connexion lexikongo) et Lingala (connexion lexilingala) avec le m√™me code.

6.2. D√©finir et impl√©menter le mod√®le WordSearchPuzzle (mots m√™l√©s)

On code une classe dans, par exemple :
com.longoka.games.puzzles.wordsearch :

WordSearchPuzzle :

id, langue (kg/ln), titre, th√®me, difficult√©,

taille de la grille (rows, cols),

grid (char[][] ou List<String>),

liste de mots √† trouver (avec traduction, etc.),

solution (positions + direction).

Ce mod√®le suivra directement le format JSON qu‚Äôon a d√©j√† d√©fini ensemble pour les mots m√™l√©s. 

brainstorming-longokaGames

6.3. Cr√©er un WordSearchGenerator

Toujours dans puzzles.wordsearch :

WordSearchGenerator :

prend une liste de LexWord ou LexVerb (ou mix),

choisit X mots,

les place dans une grille N√óN,

remplit le reste avec des lettres compatibles,

retourne un WordSearchPuzzle.

On fera d‚Äôabord simple (mots horizontaux/verticaux, directions limit√©es), puis on complexifiera.

6.4. Service par langue

Deux services fins mais clairs :

KikongoWordSearchService :

ouvre une connexion via DbConfig.openKikongoLexConnection(),

r√©cup√®re une liste de mots (ou verbes) via les repositories,

appelle WordSearchGenerator,

renvoie un WordSearchPuzzle.

LingalaWordSearchService :

m√™me chose, mais avec openLingalaLexConnection().

√áa donne une API interne du style :

WordSearchPuzzle puzzle = kikongoWordSearchService.generatePuzzle(
    theme, difficulty, nbWords
);


Plus tard, tu pourras :

soit l‚Äôexposer via une API REST,

soit l‚Äôutiliser depuis une app Android,

soit l‚Äôutiliser dans un petit CLI qui √©crit un JSON pour InDesign.

6.5. Ensuite seulement : persistance & scores

Une fois qu‚Äôon sait g√©n√©rer des puzzles :

Sauvegarder les puzzles dans 6i695q_games_stock (table puzzles, packs, etc.).

Sauvegarder les sessions de jeu (scores, temps, mots trouv√©s) dans une table game_sessions ou √©quivalent.

Brancher √ßa plus tard sur :

l‚Äôapp mobile,

√©ventuellement un mini tableau de bord web.

7. En r√©sum√© ultra-court (pour qu‚Äôon reste align√©s)

On n‚Äôest plus en mode ‚Äútests qui tra√Ænent partout‚Äù.

On a :

un backend Java propre qui compile,

une connexion solide aux DB Kikongo / Lingala,

des mod√®les LexVerb / LexWord / repositories d√©j√† en place. 

üóì 2025-12-11 ‚Äì Journal de dev ‚Ä¶

Objectif imm√©diat :

Mots m√™l√©s Kikongo & Lingala, avec :

mod√®le WordSearchPuzzle,

WordSearchGenerator,

services Kikongo/Lingala.

Si tu es ok avec ce recap, au prochain message je peux t‚Äô√©crire les signatures d√©taill√©es des classes suivantes (sans blabla, juste code) :

WordSearchPuzzle

WordToFind / WordPlacement

WordSearchGenerator (interface + m√©thode principale)

KikongoWordSearchService & LingalaWordSearchService (squelettes)