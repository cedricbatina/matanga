Je te fais un rÃ©sumÃ© structurÃ© que tu pourras presque coller tel quel dans ton journal de dev.

1ï¸âƒ£ Vision globale (rappel)

Longoka / Lexikongo / Lexilingala, câ€™est :

Un Ã©cosystÃ¨me autour des langues (Kikongo dâ€™abord, Lingala ensuite).

Une base lexicale sÃ©rieuse (DB MySQL : mots, verbes, classes nominales, dÃ©finitions FR/EN, etc.).

Des jeux pÃ©dagogiques :

mots mÃªlÃ©s, QCM, quiz de classes nominales, verbes, nombres, sÃ©ries dâ€™exercicesâ€¦

Des produits dÃ©rivÃ©s :

applis (web/mobile),

livres de jeux (InDesign),

ressources pour profs / Ã©coles,

plus tard : moteur de jeux plus costaud (C++, etc.).

Lâ€™idÃ©e centrale :

Une seule base lexicale, plusieurs sorties : jeux, livres, apps.

2ï¸âƒ£ Ã‰tat actuel du backend Java (backend-java)
ğŸ”¹ Base de donnÃ©es

On sâ€™appuie sur deux bases structurellement identiques :

6i695q_lexikongo (Kikongo)

6i695q_lingala (Lingala)

Tables principales :

verbs : verb_id, name, root, suffix, flags (active, derivedâ€¦), liens user, datesâ€¦

words : word_id, singular, plural, root, class_id, number_variability, etc.

word_meanings : sens dâ€™un mot avec language_code (fr, etc.)

verb_meanings : idem pour les verbes.

slugs : slugs uniques word / verb.

nominal_classes : class_id, class_name (n-zi, ki-bi, mu-ba, etc.)

Tu as confirmÃ© que Lexikongo et Lexilingala utilisent la mÃªme structure, ce qui est parfait pour factoriser le code.

ğŸ”¹ ModÃ¨les Java (lexique)

Dans com.longoka.games.lexikongo, on a maintenant :

LexWord

id, singular, plural, root

NominalClass (class_id + class_name)

slug

liste de LexMeaning

LexVerb

id, name, root, suffix

flags (active, derivedâ€¦)

liste de LexMeaning

LexMeaning

meaningId, languageCode, meaning

NominalClass

classId, className

NumberVariability

enum pour singular_only, plural_only, invariable, variable

Ces classes reprÃ©sentent proprement ce qui est en DB et servent de base commune Ã  tous les jeux.

ğŸ”¹ Repositories lexicaux

Toujours dans com.longoka.games.lexikongo :

LexikongoWordRepository

findRandomWords(int limit, String languageCode)

findRandomWordsByClassId(int classId, int limit, String languageCode)

LexikongoVerbRepository

findRandomVerbsByLength(int minRootLength, int maxRootLength, int limit, String languageCode)

Ces mÃ©thodes :

font les bons JOIN avec word_meanings / verb_meanings,

priorisent les sens dans une langue donnÃ©e (ex : "fr"),

remontent des LexWord / LexVerb dÃ©jÃ  enrichis avec leurs LexMeaning.

ğŸ”¹ Outils CLI â€œde debugâ€ (app)

Dans com.longoka.games.app :

DbConfig

gÃ¨re les connexions vers :

openKikongoLexConnection()

openLingalaLexConnection()

lit config/db-local.properties avec lex.kg.* et lex.ln.*.

KikongoWordsTool

se connecte Ã  6i695q_lexikongo

affiche 20 mots alÃ©atoires + toutes leurs dÃ©finitions [fr] ....

LingalaWordsTool

se connecte Ã  6i695q_lingala

affiche des mots Lingala + dÃ©finitions FR.

Tu as configurÃ© lâ€™exÃ©cution avec :

chcp 65001
$env:JAVA_TOOL_OPTIONS = "-Dfile.encoding=UTF-8"
mvn compile
mvn exec:java "-Dexec.mainClass=..."


ce qui te donne du UTF-8 correct dans la console.

3ï¸âƒ£ Moteur de mots mÃªlÃ©s opÃ©rationnel
ğŸ”¹ Lib de puzzles

Dans com.longoka.games.puzzles.wordsearch (dÃ©jÃ  existant) :

WordSearchGenerator

WordSearchPuzzle

WordToFind

Tu lâ€™utilises maintenant branchÃ© sur le vrai lexique.

ğŸ”¹ Services Kikongo basÃ©s sur le lexique
1. KikongoWordSearchService

GÃ©nÃ¨re un mot mÃªlÃ© de noms Kikongo Ã  partir de la DB lexikongo.

Deux variantes :

WordSearchPuzzle generateRandomKikongoWordSearch(
    int rows,
    int cols,
    int maxWords,
    String meaningLanguageCode
)

WordSearchPuzzle generateKikongoWordSearchForClass(
    int classId,
    int rows,
    int cols,
    int maxWords,
    String meaningLanguageCode
)


Utilise LexikongoWordRepository pour rÃ©cupÃ©rer les mots + dÃ©finitions.

Transforme les LexWord en WordToFind avec :

baseForm = forme choisie (singulier/pluriel/root)

translation = premiÃ¨re dÃ©f FR (ou fallback)

extraInfo = class nominale (n-zi, ki-bi, etc.).

2. KikongoVerbWordSearchService

GÃ©nÃ¨re un mot mÃªlÃ© de verbes Kikongo :

WordSearchPuzzle generateRandomKikongoVerbWordSearch(
    int rows,
    int cols,
    int maxWords,
    String meaningLanguageCode
)


Utilise LexikongoVerbRepository (racines, dÃ©f FR).

Place les verbes dans la grille + dÃ©f FR comme â€œindicesâ€ cÃ´tÃ© liste.

3. KikongoMixedWordSearchService

Nouveau service : mots mÃªlÃ©s mixtes noms + verbes.

Fonction typique :

WordSearchPuzzle generateMixedWordSearch(
    int rows,
    int cols,
    int nounCount,
    int verbCount,
    String meaningLanguageCode
)


Combine :

quelques noms (via LexikongoWordRepository),

quelques verbes (via LexikongoVerbRepository),

en une seule grille homogÃ¨ne.

ğŸ”¹ Tools CLI pour les mots mÃªlÃ©s

Dans com.longoka.games.app :

KikongoWordSearchTool

affiche une grille de noms + liste des WordToFind.

KikongoWordSearchByClassTool

idem, mais pour une classe nominale (ex : classe 1 -> n-zi).

KikongoVerbWordSearchTool

affiche une grille de verbes Kikongo.

KikongoMixedWordSearchTool

affiche une grille mixte noms + verbes et la liste :

Mosi [noun] {di-ma} : Un

Sasuna [verb] : Expliquer

etc.

âœ… Tout Ã§a compile et tourne (BUILD SUCCESS)
âœ… Tu vois bien les grilles + les mots Ã  trouver + les dÃ©finitions.

4ï¸âƒ£ Ce qui manque encore / limitations actuelles

Pas encore de :

JSON dâ€™export â€œofficielâ€ pour les puzzles,

API HTTP / serveur web,

intÃ©gration Nuxt,

pipeline automatique vers InDesign.

Pas encore :

de notion de difficultÃ©,

de thÃ¨me lexical (nourriture, corps, familleâ€¦),

de niveau (dÃ©butant / avancÃ©),

de scores / rÃ¨gles de jeu (câ€™est juste la gÃ©nÃ©ration de puzzle pour lâ€™instant).

CÃ´tÃ© Lingala :

on lit dÃ©jÃ  les mots + dÃ©f FR,

mais on nâ€™a pas encore de WordSearchService pour Lingala, ni de jeux associÃ©s.

5ï¸âƒ£ Roadmap proposÃ©e
ğŸŸ¢ Court terme (prochaines sessions)

Standardiser le JSON pour un puzzle de mots mÃªlÃ©s
Exemple de format cible :

{
  "language": "kg",
  "type": "wordsearch",
  "title": "Mots mÃªlÃ©s Kikongo (noms + verbes)",
  "theme": "Noms + verbes",
  "rows": 12,
  "cols": 12,
  "grid": ["KYEPLIGURAYT", "..."],
  "entries": [
    {
      "baseForm": "Mosi",
      "partOfSpeech": "noun",
      "nominalClass": "di-ma",
      "translation": "Un",
      "slug": "mosi"
    },
    {
      "baseForm": "Sasuna",
      "partOfSpeech": "verb",
      "translation": "Expliquer",
      "slug": "sasuna"
    }
  ]
}


CrÃ©er un outil dâ€™export JSON cÃ´tÃ© Java
Dans com.longoka.games.app :

KikongoWordSearchJsonExportTool

KikongoVerbWordSearchJsonExportTool

KikongoMixedWordSearchJsonExportTool

Chaque tool :

gÃ©nÃ¨re plusieurs puzzles (ex : 20 grilles),

les met dans un objet WordSearchPack,

Ã©crit un fichier target/kikongo-wordsearch-mixed-pack.json.

Nettoyage lÃ©ger / cohÃ©rence des noms

Garder lâ€™idÃ©e :

KikongoWordSearchService â†’ noms,

KikongoVerbWordSearchService â†’ verbes,

KikongoMixedWordSearchService â†’ mixte.

Plus tard, si tu veux, on pourra renommer proprement en ...PuzzleService / ...GameService.

ğŸŸ¡ Moyen terme (1â€“3 mois)

Brancher une app Nuxt / Front JS

Petit front Nuxt qui :

charge un pack JSON de puzzles,

affiche la grille de mots mÃªlÃ©s,

permet de surligner des mots trouvÃ©s,

montre les dÃ©finitions FR (ou les cache pour mode â€œplus durâ€).

Pipeline InDesign

Script (JSX) qui :

lit le JSON,

place la grille dans une page InDesign,

place la liste des mots / dÃ©finitions,

gÃ©nÃ¨re un livret de mots mÃªlÃ©s Kikongo prÃªt Ã  imprimer.

Enrichir les mÃ©tadonnÃ©es des puzzles

Ajouter dans le JSON :

difficulty (easy/medium/hard),

tags (thÃ¨mes : â€œcorpsâ€, â€œfamilleâ€, â€œÃ©coleâ€),

sourceLesson (liens avec tes leÃ§ons).

Porter les services vers Lingala

LingalaWordSearchService,

puis Ã  terme verbes Lingala si DB prÃªte.

ğŸ”µ Long terme (vision)

Ã‰cosystÃ¨me multi-jeux Longoka

Mots mÃªlÃ©s,

QCM verbes / classes nominales,

jeux de nombres,

memory / matching Kikongoâ€“FranÃ§ais,

futurs puzzles (mots croisÃ©s, anagrammesâ€¦).

Standard â€œLongoka Game Formatâ€ (LGF)

Un format JSON stable pour lâ€™ensemble des jeux (pas seulement wordsearch).

Utilisable par :

backend Java,

front Nuxt,

scripts InDesign,

futures apps mobiles,

futur moteur C++.

Moteur C++ (plus tard)

Un LongokaGameEngine en C++ qui lit les fichiers LGF (JSON).

Pour :

apps desktop / offline trÃ¨s performantes,

intÃ©gration dans dâ€™autres environnements (devices Ã©ducatifs, etc.).

Produits

Livres de jeux (Kikongo / Lingala) pour enfants/adultes.

Apps ludiques (Android, web).

Packs pour enseignants / Ã©coles (puzzles par thÃ¨me / niveau).

Potentiellement un petit â€œshopâ€ Longoka avec ces contenus.
ğŸ—“ 2025-12-12 â€“ Notes de conception
Gestion des noms kikongo dans les grilles de mots mÃªlÃ©s

Contexte

Dans la base words, la morphologie nominale kikongo est modÃ©lisÃ©e avec :

singular : forme de base / lemme (toujours renseignÃ©e dans tes donnÃ©es).

plural : forme plurielle (quand elle existe).

number_variability âˆˆ

variable

singular_only

plural_only

invariable

Objectif : dÃ©finir une forme canonique Ã  utiliser dans les puzzles â€œmots mÃªlÃ©sâ€ (WordSearch) pour Ã©viter :

les doublons (singulier + pluriel du mÃªme lexÃ¨me dans la mÃªme grille),

les usages non naturels (utiliser un â€œfaux singulierâ€ pour un mot qui est en fait uniquement pluriel),

les incohÃ©rences avec ton travail lexicographique existant.

RÃ¨gle gÃ©nÃ©rale : 1 lexÃ¨me = 1 forme dans la grille

Un enregistrement words.word_id reprÃ©sente un lexÃ¨me.
Dans une grille de mots mÃªlÃ©s :

on nâ€™utilise quâ€™une seule forme par lexÃ¨me,

le choix de cette forme dÃ©pend de number_variability.

On ne met jamais singulier + pluriel du mÃªme mot dans la mÃªme grille.

DÃ©tail des cas selon number_variability
1ï¸âƒ£ variable

Cas classique : le mot a un vrai singulier + un vrai pluriel (ex. diisu / maisu).

DÃ©cision : la forme canonique pour les puzzles = le singulier.

Raison :

cohÃ©rence : un seul point dâ€™entrÃ©e par lexÃ¨me,

plus simple pour la mÃ©morisation (on peut toujours prÃ©senter le pluriel dans la dÃ©finition / dans un autre contexte).

ğŸ‘‰ Pour variable :

forme pour la grille : singular

plural reste disponible pour lâ€™affichage dans lâ€™appli, mais pas utilisÃ© comme mot Ã  chercher en WordSearch.

2ï¸âƒ£ plural_only

Cas oÃ¹ le mot ne sâ€™emploie quâ€™au pluriel en usage rÃ©el,
mÃªme si tu as renseignÃ© singular comme lemme technique dans la DB.

DÃ©cision : pour la grille, on respecte lâ€™usage natif, donc on prend le pluriel.

ğŸ‘‰ Pour plural_only :

forme pour la grille : plural

singular = lemme technique, non utilisÃ© dans les puzzles.

3ï¸âƒ£ singular_only

Cas oÃ¹ le mot ne sâ€™emploie quâ€™au singulier.

DÃ©cision : la forme puzzle = singular (câ€™est lâ€™usage rÃ©el).

ğŸ‘‰ Pour singular_only :

forme pour la grille : singular

plural devrait en pratique Ãªtre vide ou non significatif.

4ï¸âƒ£ invariable

Cas des mots qui ne varient pas en nombre :
conjonctions, certaines qualitÃ©s / dÃ©fauts, etc.

Tu as quand mÃªme rempli singular pour ces entrÃ©es (forme de base / lemme).

DÃ©cision : la forme puzzle = singular, considÃ©rÃ© comme forme canonique neutre.

ğŸ‘‰ Pour invariable :

forme pour la grille : singular

il nâ€™y a pas de variation Ã  gÃ©rer.

RÃ©sumÃ© des rÃ¨gles (vue dev)

Pour un LexWord w :

Si number_variability = variable
â†’ baseForm = singular

Si number_variability = plural_only
â†’ baseForm = plural

Si number_variability = singular_only
â†’ baseForm = singular

Si number_variability = invariable
â†’ baseForm = singular

Si number_variability est null / inconnu (cas de sÃ©curitÃ©)
â†’ fallback = singular, mais Ã  surveiller / logger.

Et en plus :

Jamais singulier + pluriel du mÃªme word_id dans une mÃªme grille.

La dÃ©finition FR reste libre :
elle peut mentionner lâ€™autre forme (ex. â€œdiisu (sg.), maisu (pl.)â€).

Impact pour les futurs livres de mots mÃªlÃ©s

Les livres â€œMots mÃªlÃ©s â€“ Noms Kikongoâ€ utilisent ces formes canoniques.

On pourra faire des variantes par :

classes nominales (les 11 classes),

longueur de mot,

plus tard, thÃ©matique (via les traductions FR/EN, ou via des tags calculÃ©s).

Les donnÃ©es restent fidÃ¨les Ã  ta grammaire kikongo :
aucun â€œfauxâ€ singulier/pluriel nâ€™est introduit par la logique de jeu.