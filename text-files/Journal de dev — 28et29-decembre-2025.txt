Journal de dev â€” (Hier + Aujourdâ€™hui)
Contexte / objectif
Journal de dev â€” Addendum (Docs + MÃ©dias)
âœ… 5) EDIT obituary â€” MÃ©dias (images + vidÃ©os externes) : quotas + normalisation + persistance

Objectif : rendre lâ€™Ã©dition mÃ©dias fiable, compatible avec lâ€™API, et respecter les limites du plan.

Normalisation robuste des rÃ©ponses upload

Ajout de pickMediaFromUploadResponse(res) :

supporte plusieurs formes API (res.media, res.item, res.url, res.fileUrl, res.location)

Ã©vite les bugs â€œURL introuvableâ€ selon le format backend

Normalisation des items mÃ©dias cÃ´tÃ© UI

Ajout de normalizeMediaItem(m, idx) :

normalise url, thumbnailUrl, mediaType, provider, isMain, sortOrder, eventId

corrige les cas vidÃ©o dÃ©tectÃ©e mais mediaType=image

construit thumbnail YouTube si possible (via parseYouTubeId + youtubeThumbnailFromUrl)

Gestion des quotas selon plan

calculs : photosCount, videosCount, remainingPhotos, remainingVideos

rÃ¨gles :

upload fichier : images uniquement (accept="image/*" + filtre MIME)

ajout lien : consommÃ© comme vidÃ©o (YouTube/Vimeo/other)

blocage UI si quota atteint (canUploadMorePhotos, canAddMoreVideos)

si user sÃ©lectionne trop de fichiers â†’ on garde slice(0, remainingPhotos) + message â€œignorÃ©sâ€

Couverture / image principale

setAsCover(m) :

force â€œun seul mainâ€

synchronise cover + main

persiste via persistMediaAndCover()

si suppression de la cover â†’ bascule sur la prochaine image dispo

Persistance dÃ©diÃ©e

persistMediaAndCover() :

PUT /api/obituaries/:slug avec { coverImageUrl, media[], regenSlug }

mediaDirty remis Ã  false aprÃ¨s succÃ¨s

gÃ¨re le cas regenSlug si changement du nom du dÃ©funt

si slug change â†’ router.replace pour garder URL cohÃ©rente

Upload cover via endpoint media

onPickCoverFile() :

upload image via /api/obituaries/:slug/media

rÃ©cupÃ¨re URL via pickMediaFromUploadResponse

ajoute au mediaItems si pas dÃ©jÃ  prÃ©sent

set coverImageUrl automatiquement

âœ… 6) EDIT obituary â€” Documents (privÃ©s) : statut, historique, remplacement, suppression

Objectif : rendre lâ€™upload et le suivi des documents clair et cohÃ©rent (CNI / certificat / autres).

Typage docs et affichage par type

DOC_TYPES standardisÃ©s :

id_card, death_certificate, other

docsByType computed :

garantit 1 doc affichÃ© par type (conforme contrainte DB uq type)

currentDocForSelectedType :

facilite le remplacement (workflow UX)

Affichage statut + note admin

UI â€œdoc-status-gridâ€ :

badge type + badge statut (accepted, rejected, under_review, sinon missing)

affichage adminNote si prÃ©sent

boutons â€œOpenâ€ + â€œDeleteâ€ si applicable

Historique via <details> :

liste complÃ¨te des documents avec date (createdAt) + note admin + actions

Upload document : workflow remplacement

onPickDocumentFile() :

si doc du mÃªme type existe dÃ©jÃ  :

modal confirm â€œremplacerâ€

DELETE /api/obituaries/:slug/documents/:id (pour Ã©viter contrainte unique)

refresh list

POST /api/obituaries/:slug/documents (FormData : type, file)

refresh + message inline + toast succÃ¨s

Ajout docInlineMessage + docInlineTone (success/danger/info) pour UX non-bloquante

Suppression document

onDeleteDocument(d) :

confirmation via confirmStore.ask

DELETE endpoint

refresh + toast succÃ¨s

CSS/UX statuts

docStatusClass() map :

accepted â†’ badge-success

rejected â†’ badge-warning

under_review â†’ badge-neutral

dÃ©faut â†’ badge-soft

âœ… 7) CohÃ©rence â€œplan â†’ limitesâ€

Les limites plan (maxEvents, maxPhotos, maxVideos, maxContacts, maxTextChars) pilotent :

ajout dâ€™Ã©vÃ©nements extra (canAddExtraEvent)

ajout contacts (canAddContact)

upload photos / ajout vidÃ©os (canUploadMorePhotos, canAddMoreVideos)

validation validate() bloque si dÃ©passement (texte, contacts, mÃ©dias, events)

Ajout de compteurs UI :

usedEventsCount / limits.maxEvents

usedContactsCount / limits.maxContacts

photosCount / limits.maxPhotos

videosCount / limits.maxVideos
ProblÃ¨me constatÃ© : incohÃ©rences sur la page /plans (doublons â€œEssentiel 30â€, prix contradictoires, badge â€œRecommandÃ©â€ instable, tri pas fiable).

Objectif : Ã©tablir une seule source de vÃ©ritÃ© (pricingPlans.js), rendre lâ€™API plans cohÃ©rente, et Ã©viter toute confusion cÃ´tÃ© UI (plans vs obituary).

âœ… 1) Source de vÃ©ritÃ© des plans : utils/pricingPlans.js

Mise en place/renforcement dâ€™un registre central des plans (particuliers + pro + mÃ©morials + abonnements).

Ajout / clarification des champs structurants :

code, pricingTier, aliases (compat legacy)

publishDurationDays, basePriceCents/priceCents, features, sortOrder

isPublic, isRecommended

Docs policy centralisÃ©e :

DOCS_POLICY.individual : CNI requise create + publish, certificat requis sous 7 jours (non-bloquant publish)

DOCS_POLICY.pro : pas de docs requis dans ce workflow

registerPlan() :

enregistre sous plan.code

enregistre aussi sous plan.pricingTier si diffÃ©rent

enregistre aussi sous aliases[] pour compat avec anciens codes

injecte docsPolicy au plan clonÃ©

Ajout getAllPlans() triÃ©s par sortOrder (utile pour admin / debug / futures pages).

âœ… 2) API Plans : server/api/plans/index.get.js

Normalisation stable via mapBasePlan() :

expose au front : isPublic, isRecommended, sortOrder, aliases

fournit docsPolicy de maniÃ¨re cohÃ©rente

Tri cÃ´tÃ© API :

individualObituary triÃ© par sortOrder

Clarification des catÃ©gories retournÃ©es :

individualObituary, individualMemorial

proObituary, proMemorialOneOff

proSubscriptions

(alias temporaire proMemorial â†’ ancien front)

âœ… 3) UI /plans : correction logique â€œrecommendedâ€ + plan legacy

Constat : le doublon â€œEssentiel 30 legacyâ€ apparaÃ®t en public et casse la perception prix :

BASIC_30 = 14,50 â‚¬

LEGACY_30 = 25,00 â‚¬

Confort 45 = 25,00 â‚¬
=> incohÃ©rent pour lâ€™utilisateur et badge â€œRecommandÃ©â€ tombait sur le mauvais code (hardcodÃ©).

DÃ©cisions prises / proposÃ©es :

Le plan legacy (indiv_essentiel_30) doit Ãªtre compatibilitÃ© uniquement :

âœ… rester dans registry (aliases / findPlanByCode)

âŒ ne pas Ãªtre affichÃ© sur /plans

Le â€œRecommandÃ©â€ doit Ãªtre pilotÃ© par plan.isRecommended (dans pricingPlans.js), pas par code hardcodÃ©.

Correctifs concrets (Ã  appliquer/terminer) :

Dans pricingPlans.js :

ESSENTIEL_30_LEGACY.isPublic = false

ESSENTIEL_30_LEGACY.isRecommended = false

ESSENTIEL_45.isRecommended = true (choix produit actuel)

Dans /plans page :

filtrer isPublic !== false (affichage)

remplacer toutes les conditions plan.code === recommendedIndividualCode par plan.isRecommended

Ã©viter tri â€œpar prixâ€ : prÃ©fÃ©rer sortOrder (sinon le legacy peut se recaler bizarrement si un jour son prix change)

âœ… 4) Correction importante : confusion data vs plansData dans EDIT

Bug/risque identifiÃ© :

Dans pages/obituary/edit/[slug].vue :

data = rÃ©ponse /api/obituaries/:slug

plansData = rÃ©ponse /api/plans

Des computed plans utilisaient data.value?.individualObituary â†’ faux (câ€™Ã©tait lâ€™obituary payload)

DÃ©cision :

Dans EDIT, on ne liste pas les plans. Donc on supprime toute logique visible/sortByOrder/individualObituaryPlans/... si elle nâ€™est pas utile.

Si besoin futur, ces computed doivent lire plansData, jamais data.

Hardening recommandÃ© :

renommer data (obituary) en obituaryData pour Ã©viter toute confusion.

Points ouverts / Ã  faire immÃ©diatement
A) Finaliser /plans proprement

 Mettre indiv_essentiel_30 (legacy) en isPublic:false dans pricingPlans.js

 Page /plans/index.vue :

 filtrage isPublic !== false

 badge â€œRecommandÃ©â€ = plan.isRecommended

 tri par sortOrder

 supprimer le recommendedIndividualCode hardcodÃ©

B) Page de vÃ©rification / validation documents (prochaine Ã©tape)

Constat actuel :

Page utilise une ancienne logique et un filtrage incohÃ©rent entre statuts :

verified, draft, published, etc.

Il faut remettre une grammaire unique des statuts, alignÃ©e DB + API + UI.

Objectif :

Unifier le statut dâ€™une annonce (workflow) :

draft / pending_review / published / archived (ou votre set exact)

Unifier le statut des documents :

missing / under_review / accepted / rejected

Refaire les filtres admin/modo :

â€œÃ€ vÃ©rifierâ€ (annonces + docs) doit Ãªtre dÃ©terministe

sÃ©parer : statut annonce vs statut docs vs visibilitÃ©

Prochaine action (proposÃ©e)

Patch final pricingPlans.js : hide legacy + recommended sur 45j.

Patch /plans/index.vue : filtre isPublic + badge isRecommended + tri sortOrder.

On attaque ensuite la page de vÃ©rification docs :

on recense les statuts existants (DB + API)

on dÃ©finit une table de mapping unique

on patch la page + endpoint(s) si besoin
Journal de dev â€” 31/12/2025 (Admin / Obituaries)
âœ… AvancÃ©es (fait)

Page admin â€œAnnonces Ã  vÃ©rifierâ€ : refactor UI des filtres en 2 groupes distincts :

Groupe Statut de lâ€™annonce

Groupe VÃ©rification des documents

Ajout dâ€™un style â€œproâ€ pour bien diffÃ©rencier les deux filtres :

.adminobits-filter-groups en grid

.adminobits-filter-group--status bordure gauche primary

.adminobits-filter-group--verification bordure gauche warning

Correction du bug des labels dans les v-for :

statusOptions utilise opt

verificationOptions utilise option

fonction utilitaire tr(key, fallback) utilisÃ©e pour fallback si clÃ© i18n manquante

Debug & correction des erreurs de build / runtime :

erreur labelKey undefined venait dâ€™un mauvais nom de variable dans le template

erreur ... dans statusOptions cassait le JS

erreur â€œMissing initializer in const declarationâ€ : venait dâ€™une ligne cassÃ©e type const processingId sans = ref(null) (Ã  surveiller si Ã§a rÃ©apparaÃ®t)

API admin list vÃ©rifiÃ©e : GET /api/admin/obituaries

filtres supportÃ©s : status, verification, q, sort, pagination

onlyPaid=true par dÃ©faut cÃ´tÃ© API

âœ… Nettoyage DB (fait)

Objectif : dÃ©tecter / supprimer les plans obsolÃ¨tes.

VÃ©rif SQL : pricing_tier NOT IN (...) â†’ rÃ©sultat vide âœ…

Conclusion : il ne reste aucun plan inconnu en DB.

VÃ©rif migration plan :

SELECT COUNT(*) FROM obituaries WHERE pricing_tier='indiv_basic_21' â†’ 0 âœ…

Conclusion : migration indiv_basic_21 dÃ©jÃ  faite, rien Ã  refaire.

âš ï¸ Points Ã  rÃ©gler (reste Ã  faire)

CohÃ©rence â€œVÃ©rification non requiseâ€

DÃ©cision produit : mÃªme les annonces gratuites doivent Ãªtre vÃ©rifiÃ©es (CNI Ã  la crÃ©ation + certificat sous 7 jours).

Donc :

soit on supprime verification_status='not_required' et on met tout en pending si docs attendus,

soit on garde not_required uniquement pour un cas prÃ©cis (Ã  dÃ©finir), mais aujourdâ€™hui Ã§a crÃ©e de la confusion.

Traductions manquantes / clÃ©s brutes

Dans lâ€™UI : certains pricing_tier sâ€™affichent encore brut (ex: indiv_essentiel_45) quand plans.codes.<tier> nâ€™est pas dÃ©fini.

Dans le modal docs : quelques textes utilisent encore t('...') || 'fallback' au lieu de tr(...) (Ã  homogÃ©nÃ©iser).

Action : complÃ©ter fr.json pour :

plans.codes.*

adminObituaries.statusFilters.all (ou aligner sur adminObituaries.filters.all pour Ã©viter doublons)

clÃ©s adminObituaries.filterGroups.*

clÃ©s adminObituaries.docs.* + common.open/common.loading/common.close

ğŸ” Notes / observations

Vue SSR : des warnings/hydration mismatches sont apparus pendant les erreurs JS (probablement liÃ©s aux crashes en setup).

Build Vercel : erreurs dâ€™import dâ€™icÃ´nes (IconChevronLeft.vue) Ã  cause de chemins / casse (Windows vs Linux) â†’ Ã  vÃ©rifier et uniformiser.