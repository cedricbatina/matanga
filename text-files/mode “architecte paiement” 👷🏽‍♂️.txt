mode â€œarchitecte paiementâ€ ğŸ‘·ğŸ½â€â™‚ï¸ğŸ’³
Je te fais un plan complet avant quâ€™on touche Ã  la moindre ligne de code.

1. Ce quâ€™on veut exactement

Pour un plan payant (Basic / Essentiel / Prestige) :

Lâ€™annonce est crÃ©Ã©e en brouillon (draft) via /api/obituaries (ce quâ€™on a dÃ©jÃ ).

Lâ€™utilisateur arrive sur /obituary/confirm/[slug].

Sâ€™il clique sur â€œConfirmer et payerâ€ :

On lâ€™emmÃ¨ne sur une page de checkout propre (pas un pauvre bouton qui lance un POST).

Il choisit un moyen de paiement :

Carte / Stripe

PayPal

Virement bancaire (paiement offline)

Une fois le paiement validÃ© (ou confirmÃ© par un humain pour le virement), lâ€™annonce passe en :

published, visibility = public, published_at rempli.

MonÃ©tisation mise Ã  jour (payment_provider, payment_reference, amount_paid, etc.).

Les changements critiques (publication, paiement ok) sont pilotÃ©s par webhook cÃ´tÃ© serveur, pas par le front.

2. ModÃ¨le de donnÃ©es / tables
2.1. Table obituaries (existant)

On exploite ce quâ€™on a dÃ©jÃ  (ou ce quâ€™on a prÃ©vu) :

id

slug

user_id (owner)

is_free (bool)

pricing_tier (indiv_essentiel_30, â€¦)

currency

amount_paid (montant total dÃ©jÃ  payÃ©, en EUR)

publish_duration_days

status (draft, published, archived, â€¦) â€“ si tu as Ã§a

visibility (public, private, deleted soft, etc.)

published_at (datetime)

payment_provider (nullable : stripe, paypal, bank_transfer)

payment_reference (id Stripe, id PayPal, ref virement)

timestampsâ€¦

On ne rajoute pas 10 colonnes : Ã§a suffit pour savoir si une annonce est payÃ©e & publiÃ©e.

2.2. Nouvelle table obituary_payments (clean)

Pour gÃ©rer les tentatives de paiement proprement et tracer lâ€™historique :

obituary_payments
-----------------
id                BIGINT PK
obituary_id       BIGINT (FK obituary_obituaries.id)
provider          ENUM('stripe','paypal','bank_transfer')
status            ENUM('pending','requires_action','succeeded','failed','cancelled')
amount            DECIMAL(10,2)   -- montant en monnaie humaine (EUR)
currency          CHAR(3)         -- 'EUR' etc.
provider_session_id   VARCHAR(191) NULL  -- stripe checkout session id, paypal order idâ€¦
provider_payment_id   VARCHAR(191) NULL  -- stripe payment_intent, capture idâ€¦
reference         VARCHAR(191)    -- ex: MAT-OBIT-1234-XYZ
metadata_json     TEXT NULL       -- pour stocker du JSON brut si besoin
created_at        DATETIME
updated_at        DATETIME


Chaque paiement correspond Ã  une annonce.

On peut avoir plusieurs lignes (tentatives Ã©chouÃ©es, paiement final).

La source de vÃ©ritÃ© sur le â€œpayÃ© ou pasâ€ reste obituaries.amount_paid + status.

3. Flow fonctionnel global
3.1. CrÃ©ation de lâ€™annonce

Sur /obituary/create, lâ€™utilisateur choisit un plan.

POST /api/obituaries crÃ©e lâ€™annonce en :

status = 'draft'

visibility = 'private' (ou draft)

is_free + pricing_tier + publish_duration_days cohÃ©rents avec le plan

Redirection â†’ /obituary/confirm/[slug] (dÃ©jÃ  en place).

3.2. Page de confirmation /obituary/confirm/[slug]

Si plan gratuit :

Bouton â€œPublier gratuitementâ€ â†’ appel /api/obituaries/:slug/publish (POST).

Lâ€™API :

VÃ©rifie owner,

VÃ©rifie is_free === true,

Met status='published', visibility='public', published_at=NOW().

Si plan payant :

Bouton â€œConfirmer et payerâ€ â†’ redirection vers

/obituary/checkout/[slug]

ou /checkout/obituary/[slug] (Ã  choisir, mais restons cohÃ©rents avec le reste).

3.3. Page checkout /obituary/checkout/[slug]

Objectif : Ã©tape unique de finalisation.

Charge lâ€™annonce (comme confirm) + infos de plan (tiers, prix, durÃ©e).

Affiche :

RÃ©cap annonce + plan + montant.

Choix du moyen de paiement (radio / tabs) :

Stripe (carte)

PayPal

Virement bancaire

En bas : bouton â€œPayer maintenantâ€ (ou â€œGÃ©nÃ©rer mon bon de virementâ€ selon le choix).

3.3.1. Cas Stripe

Front appelle :

POST /api/obituaries/:slug/pay/stripe

Backend :

VÃ©rifie auth + owner + plan payant + status draft.

Calcule le montant Ã  partir de la config serveur (pas depuis le front).

CrÃ©e (ou rÃ©utilise) une ligne obituary_payments en pending.

CrÃ©e une Stripe Checkout Session (ou PaymentIntent + URLs success/cancel).

Sauvegarde provider_session_id et la reference.

Retourne { url: 'https://checkout.stripe.com/...' }.

Front :

window.location = url.

Stripe :

Redirige vers success_url ou cancel_url (ex: /obituary/payment/stripe/success / /obituary/payment/stripe/cancel).

Webhook Stripe (source de vÃ©ritÃ©) :

Endpoint : POST /api/payments/stripe/webhook.

Ã‰vÃ¨nements intÃ©ressants : checkout.session.completed, payment_intent.succeeded.

VÃ©rifie la signature.

RÃ©cupÃ¨re obituary_id depuis metadata (mis au moment de la crÃ©ation).

Met Ã  jour obituary_payments.status = 'succeeded'.

Met Ã  jour lâ€™obituary :

amount_paid = montant

payment_provider = 'stripe'

payment_reference = <payment_intent_id / charge_id>

status='published'

visibility='public'

published_at=NOW()

Idempotent (si le webhook est reÃ§u 2x, aucun souci).

3.3.2. Cas PayPal

Logique trÃ¨s proche :

POST /api/obituaries/:slug/pay/paypal.

Backend :

VÃ©rifie owner, plan, etc.

CrÃ©e paiement obituary_payments en pending.

CrÃ©e PayPal Order via API (server-side).

Sauvegarde provider_session_id = paypal_order_id.

Retourne lâ€™URL dâ€™approbation.

Front â†’ redirection vers PayPal.

Au retour, PayPal appelle un return_url (ex: /obituary/payment/paypal/success?token=...).

Important : on ne publie pas juste sur le retour front â†’ on appelle cÃ´tÃ© serveur lâ€™API PayPal pour capturer lâ€™ordre puis on valide.

Webhook PayPal :

POST /api/payments/paypal/webhook.

VÃ©rifie signature / cert.

Trouve obituary_payment via order_id / capture_id.

Marque succeeded, met Ã  jour lâ€™obituary (comme pour Stripe).

3.3.3. Cas Virement bancaire

Sur /obituary/checkout/[slug], user choisit â€œVirement bancaireâ€.

Front â†’ POST /api/obituaries/:slug/pay/bank-transfer.

Backend :

CrÃ©e obituary_payments en status='pending', provider='bank_transfer'.

GÃ©nÃ¨re une reference claire : MATANGA-<obituary_id>-<shortid>.

Retourne :

{
  "provider": "bank_transfer",
  "status": "pending",
  "reference": "MATANGA-1234-ABCD",
  "amount": 25.00,
  "currency": "EUR",
  "bank": {
    "iban": "...",
    "bic": "...",
    "holder": "Matanga",
    "bankName": "â€¦"
  }
}


Front :

Affiche bloc â€œInstructions virementâ€ (IBAN + BIC + rÃ©fÃ©rence, bouton copier).

PossibilitÃ© dâ€™envoyer un mail de rÃ©cap (plus tard).

Quand le virement est reÃ§u (dans ton back-office) :

Admin clique module interne â†’ action â€œMarquer comme payÃ©â€.

Ã‡a dÃ©clenche cÃ´tÃ© API la mÃªme logique que les webhooks :

obituary_payments.status = 'succeeded'

mise Ã  jour de obituaries (amount_paid, provider, published, etc.).

4. API Ã  prÃ©voir (cÃ´tÃ© server/api)

Pour rester dans ta convention server/api/... :

Checkout + choix moyen de paiement

Page : /obituary/checkout/[slug].vue consommera :

GET /api/obituaries/:slug (existant)

POST /api/obituaries/:slug/pay/stripe

POST /api/obituaries/:slug/pay/paypal

POST /api/obituaries/:slug/pay/bank-transfer

Webhooks :

POST /api/payments/stripe/webhook

POST /api/payments/paypal/webhook

Publication gratuite (dÃ©jÃ  esquissÃ©)

POST /api/obituaries/:slug/publish

VÃ©rifie is_free

Publie lâ€™annonce.

Optionnel : endpoint de statut

GET /api/obituaries/:slug/payment-status

Donne lâ€™Ã©tat pour permettre au front de rafraÃ®chir aprÃ¨s redirection.

5. Permissions & sÃ©curitÃ©

Toutes les routes utilisateurs (pay/stripe, pay/paypal, pay/bank-transfer, publish) :

Middleware auth (token JWT validÃ©).

Backend re-vÃ©rifie que obituary.user_id === user.id ou role in (admin, moderator).

VÃ©rifie que lâ€™annonce est encore en status='draft' et pas dÃ©jÃ  published.

Webhooks :

Pas dâ€™auth utilisateur (Ã©videmment), mais :

VÃ©rification stricte de la signature / secret (Stripe) ou certificat (PayPal).

Idempotence : on ne repasse pas une annonce publiÃ©e en autre chose.

Montants / plan :

Le montant utilisÃ© pour le paiement vient :

soit de la config serveur (pricingPlans cÃ´tÃ© backend),

soit des champs dÃ©jÃ  en DB (pricing_tier, is_free...), mais jamais dâ€™une valeur envoyÃ©e par le front.

6. UX / pages cÃ´tÃ© Nuxt

Pour que tout soit cohÃ©rent avec ce quâ€™on a dÃ©jÃ  :

/obituary/confirm/[slug].vue

On modifie juste onPay() :

au lieu de toast â€œTODOâ€, fait :
router.push({ path: /obituary/checkout/${slug.value} }).

Nouvelle page /obituary/checkout/[slug].vue

Layout proche de confirm :

Colonne gauche : mini-rÃ©cap annonce + plan.

Colonne droite : sÃ©lection moyen de paiement + bouton.

Ã‰tats :

loading, error, choix method, creatingSession.

IntÃ¨gre dÃ©jÃ  les toasts ($useToast) pour :

erreurs dâ€™API,

message â€œRedirection vers Stripeâ€¦â€, etc.

Pages de retour (facultatif au dÃ©but) :

/obituary/payment/success (affiche â€œMerci, on finalise votre paiementâ€ + poll sur /payment-status).

/obituary/payment/cancel (permet de relancer un paiement ou de revenir au rÃ©cap).

7. Ordre de mise en Å“uvre proposÃ©

ModÃ¨le & DB

CrÃ©er obituary_payments.

VÃ©rifier/ajuster les champs monÃ©tisation sur obituaries.

Backend â€œmÃ©tierâ€ commun

Helper genre publishObituary(obituaryId, { provider, amount, reference })

utilisÃ© par :

POST /api/obituaries/:slug/publish (gratuit)

Stripe webhook

PayPal webhook

Action admin â€œmarquer virement reÃ§uâ€

Routes â€œpayâ€ sans provider rÃ©el (mock)

Dâ€™abord, faire marcher /obituary/checkout/[slug] avec des endpoints qui retournent des URLs fictives, juste pour valider le flow.

Puis brancher Stripe (test mode).

Puis PayPal.

Puis les instructions de virement.