Journal de dev – Matanga
Date : 2025-12-02

Contexte général

Projet : Matanga, plateforme d’annonces nécrologiques (décès, veillées, obsèques, hommages) pour l’Afrique, la diaspora et les Caraïbes.

Tech : Nuxt 4 (SSR), MySQL, backend en JS avec requêtes SQL, JWT en cookies HttpOnly, Brevo (SMTP) pour l’email.

Vision : mobile-first, thème clair/sombre, design haut de gamme, très bonne accessibilité et SEO fort.

Backend – Authentification (API)

Table SQL ajoutée : refresh_tokens (gestion des refresh JWT, révocation, sécurité).

Variables d’environnement ajoutées :

JWT_ACCESS_SECRET, JWT_REFRESH_SECRET

JWT_ACCESS_EXPIRES_IN (15 min), JWT_REFRESH_EXPIRES_IN (14 jours)

Utilitaires JWT : server/utils/jwt.js

signAccessToken / signRefreshToken

verifyAccessToken / verifyRefreshToken

constantes de durée (accessTokenMaxAge, refreshTokenMaxAge)

Utilitaires cookies auth : server/utils/authCookies.js

setAuthCookies(event, accessToken, refreshToken, …)

clearAuthCookies(event)

noms de cookies : matanga_at (access) et matanga_rt (refresh), HttpOnly + SameSite=Lax + Secure en prod.

Routes API auth implémentées :

POST /api/auth/register

Création user (table users), profil individuel ou pro, attribution de rôle par défaut (user_individual ou user_pro), insertion d’un token de vérification email (table email_verification_tokens).

Envoi d’un email de vérif via Brevo (SMTP) avec lien /verify-email?token=...

Validation de base côté serveur : email, mot de passe, ville, type de compte, champs spécifiques individual/pro.

POST /api/auth/login

Récupération de l’utilisateur par email avec ses rôles (JOIN user_roles/roles).

Vérification du statut (pending_email_verification, suspended, etc.).

Vérification du mot de passe avec bcrypt.

Génération d’un access token et d’un refresh token (JWT).

Insertion du refresh token en base (table refresh_tokens).

Pose des cookies HttpOnly.

Retour d’un objet user “safe” pour le front.

POST /api/auth/logout

Lecture du refresh token depuis le cookie.

Révocation du refresh token en DB (revoked_at = NOW()).

Nettoyage systématique des cookies d’auth.

POST /api/auth/forgot-password

Input : email.

Si l’utilisateur existe : création d’un token dans password_reset_tokens avec TTL d’1h + envoi d’un email avec lien /reset-password?token=...

Réponse toujours neutre (“Si un compte existe avec cet email…”) pour ne pas exposer si l’email est connu ou non.

POST /api/auth/reset-password

Input : token + newPassword.

Vérification du token en DB (existe, pas expiré, pas déjà utilisé, user non suspendu).

Hash du nouveau mot de passe et mise à jour dans la table users.

Marquage du token comme utilisé.

Révocation de tous les refresh tokens pour ce user.

Nettoyage des cookies d’auth.

GET /api/auth/me

Retourne la session courante (userId, email, accountType, roles, city, country, locale) ou null.

Email utilitaire : server/utils/email.js

Mise en place de l’envoi d’emails via Nodemailer + SMTP Brevo (host, port, user, pass).

Fonctions :

sendEmail

sendEmailVerification (lien verify-email)

sendPasswordResetEmail (lien reset-password)

Backend – Session & middleware

Utilitaire server/utils/authSession.js

getAuthSession(event) :

Lit les cookies access/refresh.

Valide l’access token → construit une session minimale à partir du payload JWT.

Si access invalide mais refresh valide : vérifie le refresh JWT + la présence du token en DB (non révoqué, non expiré), recharge l’utilisateur depuis la DB, régénère un nouveau pair access/refresh, fait la rotation en DB et met à jour les cookies.

Hydrate event.context.auth (null ou objet session).

requireAuth(event, options) :

Vérifie qu’une session est présente, sinon 401.

Peut vérifier des rôles (ex : roles: ['admin']) et renvoyer 403 si absent.

Middleware global : server/middleware/auth.global.js

Appelle getAuthSession(event) sur chaque requête pour avoir event.context.auth dispo partout (API, SSR).

Front – Store & composables

Store Pinia : stores/auth.js

state : user, loading, error, initialized.

getters : isAuthenticated, roles, isAdmin, isPro.

actions :

login({ email, password }) → POST /api/auth/login, met à jour user.

logout() → POST /api/auth/logout, nettoie le state.

fetchMe() → GET /api/auth/me, hydrate user.

ensureAuthLoaded() pour éviter de re-fetch plusieurs fois.

Composable useAuth : composables/useAuth.js

Wrap du store auth pour exposer : user, isAuthenticated, roles, isAdmin, isPro, loading, error.

Hydratation automatique via /api/auth/me côté serveur (onServerPrefetch) et côté client (onMounted), sauf si fetchUser: false.

Design system global (CSS)

Fichier assets/css/main.css créé comme “design system Matanga” :

Variables CSS pour :

couleurs (bg, surface, text-main, text-muted, accent, etc.),

thème clair et thème sombre (via :root),

typographie (font-body, font-title),

rayons, ombres, espacements, transitions, largeurs.

Styles globaux : body, titres, paragraphes, liens.

Layout : app-shell, app-header, app-main, container, container-narrow, section, grid responsive (grid-2-cols, grid-3-cols).

Composants :

.card (+ variantes elevated, muted, header/body/footer)

Formulaires (.form, .form-field, .form-control, labels, erreurs, hints, textarea, select)

Boutons (.btn, .btn-primary, .btn-secondary, .btn-accent, .btn-ghost, .btn-danger, tailles sm/lg)

Chips & badges (.chip, .chip-accent, .badge-success, .badge-danger, etc.)

Tables (.table-wrapper, .table, styles pour th/td, hover).

Utilitaires : marges (mt-, mb-), paddings, flex (flex, flex-col, flex-row, items-center, justify-between), gap-*.

Animation légère .fade-in pour apparitions douces.

Skip-link .skip-link pour accessibilité (visible au focus).

Thème clair/sombre – useTheme + layout

Composable useTheme :

Stocke le thème dans useState('matanga-theme').

Applique data-theme="light|dark" sur document.documentElement.

Persistance en localStorage.

Prend en compte prefers-color-scheme si aucune préférence stockée.

Layout par défaut : layouts/default.vue

Layout global Matanga : header sticky avec logo, tagline et bouton de switch thème.

Bouton accessible : aria-pressed, aria-label dynamique.

Skip-link “Passer au contenu principal”.

main avec id="main-content" et role="main".

app.vue

Contient <NuxtLayout><NuxtPage/></NuxtLayout.

Définit le titre global via useHead avec titleTemplate.

Initialise useTheme pour s’assurer que le thème est appliqué dès le départ.

Pages front créées

Home : pages/index.vue

Landing page structurée en sections :

Hero : titre principal, description, CTA “Créer un compte gratuitement”, “Se connecter”.

Section “Pour qui est fait Matanga ?” (familles / pros).

Section “Comment fonctionne Matanga ?” (3 étapes).

CTA final avec mise en avant des cas d’usage (Brazzaville, Kinshasa, Abidjan, Paris, etc.).

SEO : useSeoMeta avec title, description, ogTitle, ogDescription, ogType, ogUrl, twitterCard.

Accessibilité : sections avec aria-labelledby reliées à leurs h1/h2 (ids dédiés).

Register : pages/register/index.vue

Formulaire complet de création de compte :

Switch type de compte : particulier / professionnel.

Champs communs : email, mot de passe, confirmation, ville, pays, téléphone, langue préférée.

Champs particuliers : prénom, nom.

Champs pros : nom de la structure, type de structure (pompes funèbres, église, mosquée, association, autre), adresse, site web.

Validation côté client (email, mot de passe, confirmPassword, champs obligatoires selon type).

Appel API POST /api/auth/register avec payload adapté.

Gestion des messages de succès (vérifier l’email) et des erreurs.

Redirection vers “/” si l’utilisateur est déjà connecté.

Login : pages/login/index.vue

Formulaire de connexion email + mot de passe.

Validation simple côté client.

Appel auth.login → /api/auth/login via le store.

Support d’un paramètre ?redirect=/chemin dans l’URL pour rediriger après login.

Liens vers “Mot de passe oublié” et “Créer un compte”.

Redirection vers “/” si déjà connecté.

Forgot password : pages/forgot-password/index.vue

Formulaire minimal : email.

Validation email côté client.

Appel POST /api/auth/forgot-password.

Affichage d’un message neutre de succès.

Accessibilité : aria-invalid, aria-describedby pour le champ email + role="status"/"alert" sur les messages.

Reset password : pages/reset-password/index.vue

Lecture du token dans la query (reset-password?token=...).

Si pas de token → affichage d’un message explicite + lien vers forgot-password.

Formulaire : nouveau mot de passe + confirmation.

Validation côté client (longueur, correspondance).

Appel POST /api/auth/reset-password avec token + newPassword.

Messages de succès/erreur, possibilité de rediriger vers /login ensuite.

État actuel

Authentification back + front : cycle complet en place (register, verify, login, logout, forgot, reset, me, session).

Design system global CSS : prêt, avec thèmes clair/sombre, layout, composants, utilitaires.

Pages publiques essentielles : home, register, login, forgot-password, reset-password.

Accessibilité : header avec skip-link, rôles ARIA principaux, formulaires déjà partiellement accessibles.

Prochaines étapes envisagées

Compléter l’accessibilité sur toutes les pages (aria-invalid systématique, aria-describedby pour chaque message d’erreur).

Commencer la modélisation métier : tables annonces nécrologiques, durées de publication, options (anniversaire, prolongation), tarifs, promotions, villes/pays, notifications.

APIs CRUD pour les annonces, avec filtrage par pays/ville, visibilité publique, statut (brouillon, publié, expiré).

Gestion des rôles avancés : moderator/admin pour validation d’annonces, modération, signalements.

SEO encore plus poussé : sitemap, balisage schema.org (event/obituary), meta langue, etc. 

////
1. Journal de dev – Matanga (session du jour)
1) Contexte général

Projet : Matanga – plateforme d’annonces nécrologiques & veillées pour Afrique / diaspora / Caraïbes, mobile-first, premium, SEO fort, multi-langues.

Stack :

Nuxt 4 (SSR), JavaScript only.

MySQL comme base principale.

Auth JWT côté backend, cookies HttpOnly/Secure (déjà posé conceptuellement).

Brevo (Sendinblue) pour l’email (SMTP).

2) Backend – Authentification & emails

Variables d’environnement

Mise en place (ou rappel) des variables .env pour l’email & URLs :

SMTP_HOST=smtp-relay.brevo.com

SMTP_PORT=587

SMTP_USER=…

SMTP_PASS=…

EMAIL_FROM=…

APP_URL=https://www.matanga.net

BASE_URL=https://www.matanga.net (ou http://localhost:3000 en dev)

Utilitaires backend

server/utils/db.js

Client MySQL solide avec :

gestion de pool,

fonction query() avec options (ex: requestId) pour logging,

fonction transaction() avec gestion commit/rollback et logs.

server/utils/logger.js

Fonctions logInfo et logError structurées (message + meta : email, requestId…).

server/utils/email.js

Envoi d’emails via SMTP Brevo :

sendEmailVerification({ toEmail, toName, token })

sendPasswordResetEmail({ toEmail, toName, token })

Construction des liens à partir de APP_URL (ex : /verify-email?token=..., /reset-password?token=...).

Routes API d’auth

server/api/auth/register.post.js

Inscription avec :

email, password, accountType (individual | pro),

city, country, preferredLocale,

profil particulier : firstName, lastName, phone,

profil pro : organizationName, organizationType, address, phone, websiteUrl.

Validations :

email valide,

mot de passe ≥ 8 caractères,

ville obligatoire,

champs spécifiques selon accountType.

Logique :

vérif email unique,

hash password (bcrypt),

création user (status = pending_email_verification),

création profil individuel ou pro dans les tables spécialisées,

affectation rôle (user_individual ou user_pro) via user_roles,

génération token de vérif email (TTL 24h) dans email_verification_tokens,

envoi email de vérification.

server/api/auth/login.post.js (on l’a déjà posé plus tôt dans la journée)

Authentification par email/password,

vérification status user (active, pending_email_verification, etc.),

création du JWT + refresh token,

écriture des cookies HttpOnly/Secure côté SSR.

server/api/auth/logout.post.js

Suppression / invalidation des cookies d’auth (clear token côté client).

server/api/auth/forgot-password.post.js

Génération d’un token de reset dans une table dédiée (ex: password_reset_tokens),

envoi d’un email avec lien de reset.

server/api/auth/reset-password.post.js

Vérification du token,

mise à jour du password_hash,

invalidation du token.

server/api/auth/verify-email.get.js

Vérification du token d’email,

mise à jour du status user -> active,

clean des tokens utilisés/expirés.

server/api/auth/resend-verification.post.js

Reçois un email,

si user existe et n’est pas vérifié :

régénère un token,

renvoie un email de vérification,

renvoie un message “si un compte existe…” pour ne pas leak l’existence d’un compte.

3) Front – Auth / stores / composables

Store d’auth & composable

stores/auth.js (Pinia)

State : user, isAuthenticated, pending, error.

Actions :

login(credentials),

logout(),

fetchMe() / fetchUser(),

gestion des erreurs globales.

composables/useAuth.js

Wrapper pour centraliser la logique dans les pages :

retour de isAuthenticated, user, login(), logout(), fetchUser().

option fetchUser: true pour précharger l’utilisateur quand nécessaire.

4) Front – Thème, layout, styles globaux

Thème (clair/sombre)

composables/useTheme.js

Gestion du thème :

theme = 'light' | 'dark',

toggleTheme(),

lecture/écriture dans localStorage,

synchronisation avec <html data-theme="light|dark"> pour tout le CSS.

layouts/default.vue

Layout général avec :

structure “shell” :

header avec logo “Matanga – Annonces & veillées`,

skip-link pour accessibilité,

bouton toggle thème (clair/sombre) accessible (aria-pressed, aria-label),

zone nav (future : login / profil),

<main id="main-content"><NuxtPage /></main>.

Mobile-first, centré sur un contenu clean pour l’instant.

Styles globaux

Mise en place d’un socle de classes CSS (dans un global CSS ou dans app.vue) :

Layout :

.page-centered, .container-narrow, .app-shell, .app-header, .app-main…

Cards :

.card, .card-elevated, .card-header.

Typo :

.text-muted, .text-soft, .text-xs, .text-sm…

Boutons :

.btn, .btn-primary, .btn-secondary, .btn-ghost, .btn-sm.

Formulaires :

.form, .form-field, .form-label, .form-control, .form-error, .form-error-input, .form-hint, .form-row, .form-row-inline.

Chips / badges :

.chip, .chip-accent, .badge-danger.

Animations simples :

.fade-in pour l’apparition des cartes.

C’est la base d’un design système premium Matanga, à raffiner plus tard.

5) i18n – Multi-langues

Module Nuxt i18n

Installation de @nuxtjs/i18n.

Config dans nuxt.config.js :

modules: ['@nuxtjs/i18n', ...]

i18n :

locales: fr, en, pt, es (fichiers JSON),

defaultLocale: 'fr',

strategy: 'prefix_except_default' ( / = FR, /en, /pt, /es pour le reste),

lazy: true,

langDir: 'locales',

vueI18n: './i18n.config.js' (chemin vers la config vue-i18n).

Config vue-i18n

Fichier i18n.config.js à la racine :

export default defineI18nConfig(() => ({
  legacy: false,
  locale: 'fr',
  fallbackLocale: 'fr',
  availableLocales: ['fr', 'en', 'pt', 'es']
}));


Fichiers de langues

Dossier locales/ avec au moins :

locales/fr.json :

Définit toutes les clés utilisées pour la page register :

auth.register.title, subtitle,

account_type.*,

fields.*, placeholders.*, actions.*,

errors.*, hints.*,

bloc resend pour renvoi email vérification.

en.json, pt.json, es.json à faire plus tard (copie/traduction de fr.json).

6) Page Register – UX premium + i18n

pages/register/index.vue réécrite :

Utilise useI18n() → t('auth.register.…') pour tous les textes.

Champs :

email, password, confirmPassword,

city, country, preferredLocale,

champs individuels : firstName, lastName, phone,

champs pro : organizationName, organizationType, address, phone, websiteUrl.

Switch type de compte (individual / pro) avec deux boutons stylés.

Validation côté front :

email valide,

mot de passe min 8,

confirmation identique,

ville obligatoire,

champs spécifiques par type.

Gestion erreurs :

fieldErrors par champ,

globalError pour message global.

Boutons voir/cacher mot de passe + confirmation :

showPassword, showConfirmPassword.

Intégration renvoi email de confirmation :

bouton qui appelle /api/auth/resend-verification avec l’email saisi,

resendLoading, resendMessage, resendError + textes i18n.

Redirection si déjà connecté :

useAuth(fetchUser: true),

si isAuthenticated → router.push('/').

7) Données de test – Nécrologies & événements

Tables déjà en place

users, user_roles

obituaries

obituary_events

obituary_media

obituary_contacts

Jeu de données inséré aujourd’hui (pour user_id = 1) :

Annonce 1 – Maman Marie NDINGA (Congo, Brazzaville ↔ Paris)

obituaries :

slug = 'maman-marie-ndinga-2025-brazzaville'

ville principale : Brazzaville (CG), annonce de décès.

obituary_events :

veillée principale à Brazzaville (domicile),

veillée secondaire à Paris (salle paroissiale + stream YouTube Live),

obsèques + inhumation au village (Congo, région Plateaux).

obituary_media :

portrait principal (image),

photos symboliques veillée Brazzaville / Paris,

vidéo YouTube (replay live Paris).

obituary_contacts :

contact famille Congo,

contact famille France.

Annonce 2 – Monsieur KOUADIO Koffi (Côte d’Ivoire, Abidjan ↔ Paris)

slug = 'monsieur-kouadio-koffi-2025-abidjan'

payant (premium_30d), mobile money (CI).

Événements :

veillée principale à Abidjan,

veillée diaspora à Paris (Zoom),

obsèques + inhumation à Abidjan (cimetière de Williamsville).

Médias :

visuel portrait + image veillée Abidjan.

Contacts :

contact CI,

contact diaspora France.

Annonce 3 – Gran Mè Rose DESIR (Martinique ↔ Montréal, messe de 40 jours)

slug = 'gran-me-rose-desir-2025-martinique'

Événements :

veillée à Fort-de-France (tradition antillaise),

veillée diaspora à Montréal (Facebook Live),

“messe de 40 jours” modélisée comme event_type = 'funeral' avec un titre spécifique.

Médias :

visuel principal,

images symboliques pour veillées Martinique et Montréal.

Contacts :

famille en Martinique,

contact diaspora au Canada.

Ces données vont servir à tester :

listing d’annonces,

filtrage par ville/pays,

affichage détaillé d’une annonce (timeline d’événements, médias, contacts),

SEO (title, description par annonce).
2025-12-03 – Données de test nécrologies (suite)

Ajout de 3 nouvelles annonces de test (MUKENDI – Kinshasa/Johannesburg, DIALLO – Conakry/Lyon, MBOUMA – Libreville/Paris).

Variation des cas d’usage :

multi-veillées avec live Zoom,

prière à la mosquée + inhumation au village,

cas simple avec veillée unique + messe souvenir à 40 jours.

Objectif : tester la page de détail nécrologique (timeline d’événements, affichage des contacts, supports médias) et, plus tard, le listing/filtrage par ville/pays.